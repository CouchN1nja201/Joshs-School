{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf410
{\fonttbl\f0\fswiss\fcharset77 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww9000\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural

\f0\fs24 \cf0 Joshua Braegger\
CS3100\
MW 10:00AM - 11:50 PM\
\
\
2.2\
	1.  Loading of programs from secondary storage into main memory.\
	2.  File management\
	3.  Protection\
	4.  I/O interaction\
	5.  Memory management\
\
User level programs could never provide memory management, because it would still require only one of them to provide memory management, as if there were two then they would eventually collide.  What it essentially comes down to is the operating system provides projection/security and stability.  Everything else could be done by user applications.\
\
2.3  	\
	1.  Pass them in registers\
	2.  Store them in a table in memory, then the table addressed is passed in a register.\
	3.  Store the parameters onto the stack by the program, then pop them off the stack by the operating system\
\
2.13\
	A modular kernel is similar to a layered in that all components of an operating system are in the kernel.  They are different in that in a modular approach, different modules can be loaded and unloaded into the main kernel, where in a layered approach, there are different "layers" to the kernel (ie one is drivers, scheduler, etc, then one is the API, etc).}